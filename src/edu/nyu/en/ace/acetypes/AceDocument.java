// -*- tab-width: 4 -*-
//Title:        JET
//Copyright:    2003, 2004, 2005
//Author:       Ralph Grishman
//Description:  A Java-based Information Extraction Toolkil
//              (ACE extensions)

package edu.nyu.en.ace.acetypes;

import java.util.*;
import java.io.*;

import org.w3c.dom.*;
import org.xml.sax.*;

import javax.xml.parsers.*;

/**
 *  an Ace Document, including entities, time expressions, relations,
 *  and values, either obtained from an APF file or generated by the
 *  system.
 */

public class AceDocument implements java.io.Serializable {

	private static final long serialVersionUID = -4776730511018454749L;
	
	public int ignoredCoreferenceGroupDueToOveralpingEventMentions = 0;
	public int ignoredEventMentionsDueToOverlapingEventMentions = 0;
	public int numEventMentionsAfterRemovingOverlapping = 0;

	private static DocumentBuilder builder = null;

	/**
	 *  the name of the source file
	 */

	public edu.nyu.en.perceptron.types.Document sourceDoc;
	
	public String nuggetFile = "";
	public String hopperFile = "";

	/**
	 *  the type of source:  newswire or bnews
	 */

	public String sourceType;

	/**
	 *  the document ID
	 */

	public String docID;
	/**
	 *  a list of the events in the document
	 */
	
	public String kit_id;
	
	//events in the original annotated dataset
	public ArrayList<AceEvent> originalEvents = new ArrayList<AceEvent>();
	
	//event and event mentions after removing the event mentions that overlap with others
	public ArrayList<AceEvent> events = new ArrayList<AceEvent>();
	public List<AceEventMention> eventMentions = new ArrayList<AceEventMention>();
	
	//this is the ids of the event mentions really appearing in the sentences of the final dataset, this is a subset of ids in eventMentions
	//the event mentions in eventMentions might still be removed due to the assignment to the sentences (based on spans and token indexes)
	public ArrayList<String> employedEventMentionIds = new ArrayList<String>();
	
	//essentially, employedEventMentionIds is subset of eventMentions is subset of originalEvents
	
	private static final String encoding = "UTF-8";//"ISO-8859-1";  // default:  ISO-LATIN-1

	
	public AceDocument (edu.nyu.en.perceptron.types.Document sourceDoc, String nuggetFile, String hopperFile) throws IOException {
		
		this.sourceDoc = sourceDoc;
		this.nuggetFile = nuggetFile;
		this.hopperFile = hopperFile;
		
		try {
		// initialize APF reader
		if (builder == null) {
			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
			factory.setValidating(false);
			builder = factory.newDocumentBuilder();
			}
		
			analyzeDocument(sourceDoc, nuggetFile, hopperFile);
			
		} catch (SAXException e) {
			System.err.println ("AceDocument:  Exception in initializing APF reader: " + e);
		} catch (IOException e) {
			System.err.println ("AceDocument:  Exception in initializing APF reader: " + e);
		} catch (ParserConfigurationException e) {
			System.err.println ("AceDocument:  Exception in initializing APF reader: " + e);
		}
	}

	private void analyzeDocument (edu.nyu.en.perceptron.types.Document sourceDoc, String nuggetFile, String hopperFile)
	    throws SAXException, IOException {
		Document nuggetDoc = builder.parse(nuggetFile);
		Document hopperDoc = builder.parse(hopperFile);
		readAPFdocument (sourceDoc, nuggetDoc, hopperDoc);
		cleanEvents();
	}

	/**
	 *  read APF document and create entities and relations
	 */

	void readAPFdocument (edu.nyu.en.perceptron.types.Document sourceDoc, Document nuggetDoc, Document hopperDoc) {
		NodeList hopperFileElements = hopperDoc.getElementsByTagName("deft_ere_event_nuggets");
		Element hopperFileElement = (Element) hopperFileElements.item(0);
		sourceType = hopperFileElement.getAttribute("source_type");
		docID = hopperFileElement.getAttribute("doc_id");
		kit_id = hopperFileElement.getAttribute("kit_id");

		NodeList hopperElements = hopperDoc.getElementsByTagName("hopper");
		for (int i=0; i<hopperElements.getLength(); i++) {
			Element hopperElement = (Element) hopperElements.item(i);
			AceEvent event = new AceEvent (hopperElement, this);
			addEvent(event);
		}
	}

	public void addEvent (AceEvent event) {
//		events.add(event);
//		this.eventMentions.addAll(event.mentions);
		originalEvents.add(event);
	}
	
	// ensure that the event mentions are not overlapping, i.e, each token has only one event label, this is to simplify the problem
	private void cleanEvents() {
		ArrayList<AceEventMention> storingMentions = new ArrayList<AceEventMention>();
		
		for (AceEvent event : originalEvents) {
			ignoredEventMentionsDueToOverlapingEventMentions += event.cleanMentions(storingMentions);
			if (event.mentions.size() > 0) {
				this.events.add(event);
				this.eventMentions.addAll(event.mentions);
			}
			else {
				ignoredCoreferenceGroupDueToOveralpingEventMentions++;
			}
		}
		
		numEventMentionsAfterRemovingOverlapping += this.eventMentions.size();
	}
	
	/*  assumes elementType is a leaf element type */

	static String getElementText (Element e, String elementType) {
		NodeList typeList = e.getElementsByTagName(elementType);
		Element typeElement = (Element) typeList.item(0);
		String text = (String) typeElement.getFirstChild().getNodeValue();
		return text;
	}

	/**
	 *  writes the AceDocument to 'w' in APF format.
	 */

	public void write (PrintWriter w) {
		w.println("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
		w.println("<deft_ere_event_nuggets kit_id=\"" + this.kit_id + "\"" + 
				   " doc_id=\"" + this.docID + "\"" + 
				   " source_type=\"" + this.sourceType + "\"" + ">");
		w.println("  <hoppers>");
		
		for (int i=0; i<events.size(); i++) {
			AceEvent event = (AceEvent) events.get(i);
			event.write(w);
		}
		w.println ("  </hoppers>");
		w.println ("</deft_ere_event_nuggets>");
		w.close();
	}

	public static void main (String[] args) throws Exception 
	{
	}
}
